<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{{ job_title }} 채용 서류 에디터</title>
    <link rel="stylesheet" href="/static/style.css" />
  </head>
  <body>
    <div class="container">
      <h1>✨ {{ job_title }} 채용 서류 맞춤 에디터 ✨</h1>
      <p class="job-description">현재 직무: <strong>{{ job_title }}</strong></p>

      <div id="document-diagram">
        <div class="diagram-node job-node" data-doc-type="job">
          {{ job_title }}
        </div>
        <div class="initial-documents">
          <div
            class="diagram-node document-node"
            data-doc-type="resume"
            data-version="0"
          >
            이력서
          </div>
          <div
            class="diagram-node document-node"
            data-doc-type="cover_letter"
            data-version="0"
          >
            자기소개서
          </div>
          <div
            class="diagram-node document-node"
            data-doc-type="portfolio"
            data-version="0"
          >
            포트폴리오
          </div>
        </div>
      </div>

      <div id="edit-modal" class="modal">
        <div class="modal-content">
          <span class="close-button">&times;</span>
          <h2 id="modal-title"></h2>
          <div
            id="loading-overlay"
            class="loading-overlay"
            style="display: none"
          >
            <div class="spinner"></div>
            <p style="margin-top: 20px; font-weight: bold">
              AI가 문서를 분석하고 있습니다. 잠시만 기다려 주세요...
            </p>
          </div>
          <form id="document-form">
            <div id="form-fields"></div>
            <div
              id="ai-feedback-area"
              style="
                margin-top: 20px;
                padding: 15px;
                background-color: #e6f7ff;
                border: 1px solid #91d5ff;
                border-radius: 5px;
                display: none;
              "
            >
              <h3>💡 AI 피드백</h3>
              <p id="ai-feedback-content"></p>
            </div>
            <button type="submit">저장 및 분석</button>
          </form>
        </div>
      </div>
    </div>

    <script>
      // JavaScript for diagram drawing, modal control, and API calls
      // 매우 복잡하므로 주요 로직만 설명합니다.

      const jobTitle = "{{ job_title }}";
      const documentDiagram = document.getElementById("document-diagram");
      const editModal = document.getElementById("edit-modal");
      const modalTitle = document.getElementById("modal-title");
      const formFields = document.getElementById("form-fields");
      const aiFeedbackArea = document.getElementById("ai-feedback-area");
      const aiFeedbackContent = document.getElementById("ai-feedback-content");
      const documentForm = document.getElementById("document-form");
      let currentDocType = "";
      let currentDocVersion = 0; // 각 문서 타입별 현재 활성 버전 (0은 초기 버전)

      // 각 문서 타입별 데이터 및 버전 관리를 위한 객체 (클라이언트 사이드 임시 저장)
      const documentData = {
        resume: [
          {
            version: 0,
            content: {},
            displayContent: "이력서 (초기)",
            koreanName: "이력서",
            feedback: null,
          },
        ],
        cover_letter: [
          {
            version: 0,
            content: {},
            displayContent: "자기소개서 (초기)",
            koreanName: "자기소개서",
            feedback: null,
          },
        ],
        portfolio: [
          {
            version: 0,
            content: {},
            displayContent: "포트폴리오 (초기)",
            koreanName: "포트폴리오",
            feedback: null,
          },
        ],
      };

      // 다이아그램 그리기 함수 (초기 로드 및 업데이트 시 호출)
      function drawDiagram() {
        documentDiagram.innerHTML = `<div class="diagram-node job-node" data-doc-type="job">${jobTitle}</div>`;
        const docsContainer = document.createElement("div");
        docsContainer.className = "initial-documents"; // 기존 CSS 클래스 재사용

        Object.keys(documentData).forEach((docType) => {
          const docColumn = document.createElement("div");
          docColumn.className = "document-column"; // 각 문서 타입을 위한 수직 컨테이너

          const versions = documentData[docType];
          versions.forEach((versionData, index) => {
            const isLatest = index === versions.length - 1;
            // createDocumentNode에 한글 이름(versionData.koreanName)과 최신 버전 여부를 전달합니다.
            const docNode = createDocumentNode(
              docType,
              versionData.version,
              versionData.displayContent,
              versionData.koreanName,
              isLatest
            );
            docColumn.appendChild(docNode);
          });

          docsContainer.appendChild(docColumn);
        });

        documentDiagram.appendChild(docsContainer);
        setupNodeClickEvents();
      }

      // 문서 노드 생성 함수
      function createDocumentNode(
        type,
        version,
        displayText,
        koreanName,
        isLatest
      ) {
        const node = document.createElement("div");
        node.className = "diagram-node document-node";
        node.dataset.docType = type;
        node.dataset.version = version;

        if (koreanName) {
          node.dataset.koreanName = koreanName;
        }

        let content = `<span>${displayText}</span>`;
        // 최신 버전이 아니면서, 버전 0(초기)이 아닌 노드에만 '되돌리기' 버튼 추가
        if (!isLatest) {
          content += `<button class="rollback-button" data-doc-type="${type}" data-version="${version}">되돌리기</button>`;
        }
        node.innerHTML = content;
        return node;
      }

      // 노드 클릭 이벤트 설정 (모달 열기)
      function setupNodeClickEvents() {
        // '되돌리기' 버튼 이벤트 리스너 설정
        document.querySelectorAll(".rollback-button").forEach((button) => {
          button.onclick = (e) => {
            e.stopPropagation(); // 이벤트 버블링 방지
            const typeToRollback = e.target.dataset.docType;
            const versionToRollback = parseInt(e.target.dataset.version, 10);

            if (
              confirm(
                `${documentData[typeToRollback][0].koreanName} 문서를 버전 ${versionToRollback}으로 되돌리시겠습니까? 이 작업은 새 버전을 생성합니다.`
              )
            ) {
              const newVersion = documentData[typeToRollback].length;
              const contentToRestore = documentData[typeToRollback].find(
                (v) => v.version === versionToRollback
              ).content;
              const originalKoreanName =
                documentData[typeToRollback][0].koreanName;

              documentData[typeToRollback].push({
                version: newVersion,
                content: contentToRestore,
                displayContent: `${originalKoreanName} (v${newVersion} - 복원됨)`,
                koreanName: originalKoreanName,
              });

              drawDiagram();
              alert("문서가 복원되었습니다.");
            }
          };
        });

        document
          .querySelectorAll(".diagram-node.document-node")
          .forEach((node) => {
            node.onclick = async (e) => {
              // 클릭된 노드의 문서 타입, 버전, 한글 이름 가져오기
              const clickedNode = e.target.closest(".document-node");
              currentDocType = clickedNode.dataset.docType;
              currentDocVersion = parseInt(clickedNode.dataset.version, 10);
              // 데이터 속성에 저장된 한글 이름을 일관되게 사용
              const currentDocTitle = clickedNode.dataset.koreanName;

              // 모달 제목 설정 (버전 정보 포함)
              modalTitle.textContent = `${currentDocTitle} 편집 (v${currentDocVersion})`;

              // 해당 문서 타입과 버전에 맞는 내용과 피드백 로드
              const versionData = documentData[currentDocType].find(
                (d) => d.version === currentDocVersion
              );
              const docContent = versionData.content;
              const savedFeedback = versionData.feedback;

              // 직무별 문서 양식 불러오기 (백엔드 API 호출)
              const formSchema = await fetch(
                `/api/job_schema/${currentDocType}?job_slug=${jobTitle
                  .replace(/ /g, "-")
                  .toLowerCase()}`
              ).then((res) => res.json());
              renderFormFields(formSchema.fields, docContent);

              // 저장된 피드백이 있으면 보여주고, 없으면 숨김
              if (savedFeedback) {
                aiFeedbackContent.textContent = savedFeedback;
                aiFeedbackArea.style.display = "block";
              } else {
                aiFeedbackArea.style.display = "none";
              }

              editModal.style.display = "block";
            };
          });

        // 롤백 버튼 이벤트 설정
        document.querySelectorAll(".rollback-button").forEach((button) => {
          button.onclick = (e) => {
            e.stopPropagation(); // 노드 클릭 이벤트 방지
            const typeToRollback = button.dataset.docType;
            const versionToRollback = parseInt(button.dataset.version);

            const targetData = documentData[typeToRollback].find(
              (d) => d.version === versionToRollback
            );
            if (targetData) {
              alert(
                `${targetData.koreanName}을(를) 버전 ${versionToRollback}으로 되돌립니다.`
              );

              currentDocType = typeToRollback;
              currentDocVersion = versionToRollback;

              // 한글 이름을 사용하여 모달 제목 설정
              const docTitle = documentData[typeToRollback][0].koreanName;
              modalTitle.textContent = `${docTitle} (버전 ${versionToRollback}) 내용 편집`;
              const docContent = documentData[typeToRollback].find(
                (d) => d.version === versionToRollback
              ).content;

              fetch(`/api/job_schema/${currentDocType}?job_slug=${jobTitle}`)
                .then((res) => res.json())
                .then((formSchema) =>
                  renderFormFields(formSchema.fields, docContent)
                );

              aiFeedbackArea.style.display = "none";
              editModal.style.display = "block";
            }
          };
        });
      }

      // 폼 필드 렌더링 함수
      function renderFormFields(fields, currentContent) {
        const currentDocTitle = document.querySelector(
          `.document-node[data-doc-type='${currentDocType}']`
        ).dataset.koreanName;
        formFields.innerHTML = "";
        if (currentDocType === "portfolio") {
          // 포트폴리오 요약 전용 UI
          formFields.innerHTML = `
                    <div class="input-group">
                        <label>포트폴리오 PDF 업로드:</label>
                        <input type="file" name="portfolio_pdf" accept=".pdf">
                    </div>
                    <div class="input-group">
                        <label>포트폴리오 링크 입력:</label>
                        <input type="text" name="portfolio_link" placeholder="포트폴리오가 업로드된 웹사이트, 블로그, Github 등 링크를 입력하세요.">
                    </div>
                `;
          // '요약 및 다운' 버튼을 모달 하단에 표시
          const submitBtn = document.querySelector(
            '#document-form button[type="submit"]'
          );
          submitBtn.textContent = "요약 및 다운";
          // 기존 submit 이벤트 제거 후 새로 등록
          documentForm.onsubmit = async (e) => {
            e.preventDefault();
            const pdfInput = document.querySelector(
              'input[name="portfolio_pdf"]'
            );
            const linkInput = document.querySelector(
              'input[name="portfolio_link"]'
            );
            const formData = new FormData();
            formData.append("job_title", jobTitle);
            if (pdfInput.files.length > 0) {
              formData.append("portfolio_pdf", pdfInput.files[0]);
            }
            if (linkInput.value.trim()) {
              formData.append("portfolio_link", linkInput.value.trim());
            }
            if (
              formData.has("portfolio_pdf") ||
              formData.get("portfolio_link")
            ) {
              const loadingOverlay = document.getElementById("loading-overlay");
              loadingOverlay.style.display = "flex";
              try {
                const response = await fetch("/api/portfolio_summary", {
                  method: "POST",
                  body: formData,
                });
                loadingOverlay.style.display = "none";
                if (response.ok) {
                  const blob = await response.blob();
                  const url = window.URL.createObjectURL(blob);
                  const a = document.createElement("a");
                  a.href = url;
                  a.download = "portfolio_summary.pdf";
                  document.body.appendChild(a);
                  a.click();
                  a.remove();
                  window.URL.revokeObjectURL(url);
                  alert("요약 PDF가 다운로드되었습니다.");
                } else {
                  const result = await response.json();
                  alert(result.error || "요약 실패");
                }
              } catch (err) {
                loadingOverlay.style.display = "none";
                alert("서버 오류: " + err);
              }
            } else {
              alert("PDF 파일을 업로드하거나 링크를 입력하세요.");
            }
          };
          return;
        }
        // --- 자기소개서 고정 질문 및 글자수 카운터 추가 시작 ---
        else if (currentDocType === "cover_letter") {
          const qaContainer = document.createElement("div");
          qaContainer.id = "qa-container";
          qaContainer.innerHTML = `
                    <div class="input-group">
                        <label>1. 해당 직무의 지원동기와 전문성을 기르기 위해 노력한 경험을 서술하시오.</label>
                        <textarea name="motivation_expertise" placeholder="내용을 입력하세요." style="width: 100%; min-height: 120px;">${
                          currentContent.motivation_expertise || ""
                        }</textarea>
                        <div class="char-counter" style="text-align: right; font-size: 0.9em; color: #666; margin-top: 3px;">
                            글자수: <span class="char-count">${
                              (currentContent.motivation_expertise || "").length
                            }</span>
                        </div>
                    </div>
                    <div class="input-group" style="margin-top: 20px;">
                        <label>2. 공동의 목표를 위해 협업을 한 경험을 서술하시오.</label>
                        <textarea name="collaboration_experience" placeholder="내용을 입력하세요." style="width: 100%; min-height: 120px;">${
                          currentContent.collaboration_experience || ""
                        }</textarea>
                        <div class="char-counter" style="text-align: right; font-size: 0.9em; color: #666; margin-top: 3px;">
                            글자수: <span class="char-count">${
                              (currentContent.collaboration_experience || "")
                                .length
                            }</span>
                        </div>
                    </div>
                `;
          formFields.appendChild(qaContainer);

          // 각 textarea에 글자 수 카운터 이벤트 리스너 추가
          qaContainer.querySelectorAll("textarea").forEach((textarea) => {
            const charCountSpan =
              textarea.nextElementSibling.querySelector(".char-count");
            textarea.addEventListener("input", () => {
              charCountSpan.textContent = textarea.value.length;
            });
          });
          // 자기소개서는 "저장 및 분석" 버튼 기능을 유지합니다.
          const submitBtn = document.querySelector(
            '#document-form button[type="submit"]'
          );
          submitBtn.textContent = "저장 및 분석";
          // 기존 submit 이벤트 리스너가 다시 연결되도록 함 (renderFormFields 밖에서 처리)
          documentForm.onsubmit = handleDocumentFormSubmit; // 아래에 별도 함수로 분리
          return;
        }
        // --- 자기소개서 고정 질문 및 글자수 카운터 추가 끝 ---
        fields.forEach((field) => {
          const div = document.createElement("div");
          div.className = "input-group";
          if (field.type === "textarea") {
            div.innerHTML = `
                        <label>${field.label}:</label>
                        <textarea name="${field.name}" placeholder="${
              field.placeholder || ""
            }">${currentContent[field.name] || ""}</textarea>
                    `;
          } else if (field.type === "text") {
            div.innerHTML = `
                        <label>${field.label}:</label>
                        <input type="text" name="${field.name}" value="${
              currentContent[field.name] || ""
            }" placeholder="${field.placeholder || ""}">
                    `;
          } else if (field.type === "custom_qa") {
            // 자기소개서의 질문/답변 필드 (이제 사용되지 않음)
            // 이 부분은 더 이상 사용되지 않습니다.
          }
          formFields.appendChild(div);
        });
        // 자기소개서가 아닌 다른 문서 타입은 "저장 및 분석" 버튼 기능을 유지합니다.
        const submitBtn = document.querySelector(
          '#document-form button[type="submit"]'
        );
        submitBtn.textContent = "저장 및 분석";
        documentForm.onsubmit = handleDocumentFormSubmit; // 아래에 별도 함수로 분리
      }

      // 자기소개서 글자수 카운터 기능을 위한 도우미 함수 (이제 사용되지 않음)
      // function addQaField(container, question = '', answer = '') { ... }

      // 폼 제출 (저장 및 AI 분석 요청) 로직을 별도 함수로 분리
      const handleDocumentFormSubmit = async (e) => {
        e.preventDefault();
        const formData = new FormData(documentForm);
        const docContent = {};

        // 자기소개서 고정 질문 처리
        if (currentDocType === "cover_letter") {
          docContent["motivation_expertise"] =
            formData.get("motivation_expertise") || "";
          docContent["collaboration_experience"] =
            formData.get("collaboration_experience") || "";
        }
        // 일반 필드 처리 (자기소개서가 아닌 경우)
        else {
          for (let [key, value] of formData.entries()) {
            docContent[key] = value;
          }
        }

        // 내용 유효성 검사 (자기소개서 고정 질문에 맞게 수정)
        let isEmpty = false;
        if (currentDocType === "cover_letter") {
          if (
            !docContent["motivation_expertise"].trim() &&
            !docContent["collaboration_experience"].trim()
          ) {
            isEmpty = true;
          }
        } else {
          // resume, career_statement 등 기존 문서 타입
          if (
            Object.keys(docContent).length === 0 ||
            Object.values(docContent).every(
              (v) => typeof v === "string" && v.trim() === ""
            )
          ) {
            isEmpty = true;
          }
        }

        if (isEmpty) {
          alert("분석할 내용이 없습니다. 내용을 입력해주세요.");
          return; // 분석 중단
        }

        // AI 분석 요청
        try {
          // 백엔드 API로 문서 내용과 타입 전송 (FormData 사용)
          const analysisFormData = new FormData();
          analysisFormData.append("job_title", jobTitle);
          analysisFormData.append(
            "document_content",
            JSON.stringify(docContent)
          ); // 객체를 JSON 문자열로 변환
          analysisFormData.append("current_version", currentDocVersion);

          const loadingOverlay = document.getElementById("loading-overlay");
          const formElements = document.getElementById("form-fields");

          loadingOverlay.style.display = "flex";
          formElements.style.display = "none"; // Hide form fields

          const response = await fetch(
            `/api/analyze_document/${currentDocType}`,
            {
              method: "POST",
              // FormData를 사용할 때는 Content-Type 헤더를 브라우저가 자동으로 설정하도록 둡니다.
              body: analysisFormData,
            }
          );
          const result = await response.json();

          loadingOverlay.style.display = "none";
          formElements.style.display = "block"; // Show form fields

          if (response.ok) {
            aiFeedbackContent.textContent = result.feedback;
            aiFeedbackArea.style.display = "block";

            // 1. Update the content of the currently edited version.
            const versionToUpdate = documentData[currentDocType].find(
              (d) => d.version === currentDocVersion
            );
            if (versionToUpdate) {
              versionToUpdate.content = docContent;
            }

            // 2. Create a new version with the updated content.
            const newVersion = documentData[currentDocType].length;
            const originalKoreanName =
              documentData[currentDocType][0].koreanName;
            documentData[currentDocType].push({
              version: newVersion,
              content: docContent,
              displayContent: `${originalKoreanName} (v${newVersion})`,
              koreanName: originalKoreanName,
              feedback: result.feedback, // Store the feedback with the new version
            });
            currentDocVersion = newVersion;
            drawDiagram();
            alert("문서가 저장되고 분석되었습니다. AI 피드백을 확인하세요.");
          } else {
            alert(`분석 실패: ${result.error || "알 수 없는 오류"}`);
          }
        } catch (error) {
          console.error("API 통신 오류:", error);
          alert("서버와 통신 중 오류가 발생했습니다.");
          const loadingOverlay = document.getElementById("loading-overlay");
          const formElements = document.getElementById("form-fields");

          loadingOverlay.style.display = "none";
          formElements.style.display = "block"; // Show form fields
        }
      };

      // 초기 폼 제출 이벤트 리스너 설정
      documentForm.onsubmit = handleDocumentFormSubmit;

      // 모달 닫기 버튼
      document.querySelector(".close-button").onclick = () => {
        editModal.style.display = "none";
      };
      // 모달 바깥 클릭 시 닫기
      window.onclick = (event) => {
        if (event.target == editModal) {
          editModal.style.display = "none";
        }
      };

      // 초기 다이아그램 그리기
      drawDiagram();
    </script>
  </body>
</html>
